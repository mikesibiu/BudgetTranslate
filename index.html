<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BudgetTranslate</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üåê</text></svg>">
    <script src="/socket.io/socket.io.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header .badge {
            display: inline-block;
            background: rgba(255,255,255,0.2);
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
        }

        .status {
            padding: 15px;
            text-align: center;
            font-weight: 500;
            border-bottom: 2px solid #eee;
        }

        .status.ready { background: #e8f5e9; color: #2e7d32; }
        .status.listening { background: #e3f2fd; color: #1565c0; }
        .status.error { background: #ffebee; color: #c62828; }

        .controls {
            padding: 30px;
            background: #f8f9fa;
        }

        .control-row {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            align-items: center;
        }

        .control-group {
            flex: 1;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #333;
        }

        select {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-size: 16px;
        }

        .button-group {
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }

        .control-group-inline {
            display: flex;
            align-items: center;
            gap: 5px;
            background: #f5f5f5;
            padding: 8px 15px;
            border-radius: 25px;
        }

        .speed-select {
            padding: 6px 12px;
            border: 2px solid #667eea;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 600;
            background: white;
            color: #667eea;
            cursor: pointer;
            outline: none;
            transition: all 0.3s ease;
        }

        .speed-select:hover {
            background: #667eea;
            color: white;
        }

        /* Mode Toggle */
        .mode-toggle-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
            gap: 10px;
        }

        .mode-toggle-label {
            font-size: 0.9em;
            color: #666;
            font-weight: 500;
        }

        .mode-toggle {
            display: flex;
            background: #f0f0f0;
            border-radius: 25px;
            padding: 4px;
            gap: 4px;
            max-width: 320px;
        }

        .mode-option {
            flex: 1;
            text-align: center;
            padding: 8px 20px;
            border-radius: 20px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 500;
            color: #666;
            transition: all 0.3s ease;
        }

        .mode-option.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        .mode-option:hover:not(.active) {
            background: #e0e0e0;
        }

        .btn {
            padding: 15px 40px;
            border: none;
            border-radius: 50px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-compact {
            padding: 12px 30px;
            font-size: 1em;
            min-width: 140px;
            text-align: center;
        }

        .btn-start {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        /* Desktop: show full text, hide short text */
        .btn-text-full {
            display: inline;
        }

        .btn-text-short {
            display: none;
        }

        .btn-start:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .btn-stop {
            background: #e53935;
            color: white;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .results {
            padding: 30px;
        }

        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .results h2 {
            color: #333;
        }

        .translation-count {
            background: #667eea;
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
        }

        .export-btn {
            padding: 8px 20px;
            background: #4caf50;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            margin-left: 10px;
            transition: all 0.3s ease;
        }

        .export-btn:hover:not(:disabled) {
            background: #45a049;
            transform: translateY(-2px);
        }

        .export-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .interim-box {
            background: #fff3e0;
            border-left: 4px solid #ff9800;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 8px;
            min-height: 60px;
        }

        .interim-label {
            font-size: 0.8em;
            color: #ff9800;
            font-weight: 600;
            margin-bottom: 5px;
        }

        .interim-text {
            color: #666;
            font-style: italic;
        }

        .audio-level-container {
            padding: 15px;
            background: #e8f5e9;
            border-left: 4px solid #4caf50;
            margin: 0 30px 20px 30px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .audio-level-label {
            font-size: 0.9em;
            color: #4caf50;
            font-weight: 600;
            min-width: 120px;
        }

        .audio-level-meter {
            flex: 1;
            height: 20px;
            background: #fff;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #4caf50;
        }

        .audio-level-bar {
            height: 100%;
            background: linear-gradient(90deg, #4caf50 0%, #8bc34a 50%, #ffc107 75%, #ff5722 100%);
            width: 0%;
            transition: width 0.1s ease;
        }

        .audio-level-text {
            min-width: 50px;
            text-align: right;
            font-weight: 600;
            color: #4caf50;
        }

        .gain-control-container {
            padding: 15px;
            background: #f0f4ff;
            border-left: 4px solid #667eea;
            margin: 0 30px 20px 30px;
            border-radius: 8px;
        }

        .gain-control-label {
            font-size: 0.9em;
            color: #667eea;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .gain-slider {
            width: 100%;
            margin: 10px 0;
        }

        .gain-value {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 600;
        }

        .translation-item {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            animation: slideIn 0.3s ease;
        }

        .translation-item.interim {
            background: #fffbea; /* Pale yellow for 10-second interim translations */
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .translation-item .original {
            display: none; /* Hide Romanian text on all screen sizes */
        }

        .translation-item .translated {
            color: #333;
            font-size: 1.1em;
            font-weight: 500;
        }

        .empty-state {
            text-align: center;
            padding: 40px;
            color: #999;
        }

        .stats {
            display: flex;
            gap: 20px;
            padding: 20px;
            background: #f0f0f0;
            border-top: 2px solid #ddd;
        }

        .stat-item {
            flex: 1;
            text-align: center;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            font-size: 0.9em;
            color: #666;
            margin-top: 5px;
        }

        /* Mobile-specific styles */
        @media (max-width: 768px) {
            body {
                padding: 0;
            }

            .container {
                border-radius: 0;
                min-height: 100vh;
            }

            /* Compact header */
            .header {
                padding: 10px 15px;
            }

            .header h1 {
                font-size: 1.3em;
                margin-bottom: 0;
            }

            .header p {
                display: none; /* Hide subtitle */
            }

            .header .badge {
                display: none; /* Hide badge */
            }

            /* Hide status bar on mobile */
            .status {
                display: none;
            }

            .controls {
                padding: 10px 15px;
            }

            /* Hide audio source selector on mobile */
            .control-row:first-child {
                display: none;
            }

            /* Language selectors side by side */
            .control-row {
                flex-direction: row;
                gap: 8px;
                margin-bottom: 8px;
            }

            .control-group {
                flex: 1;
            }

            /* Hide labels on mobile */
            .control-group label {
                display: none;
            }

            select {
                padding: 8px;
                font-size: 14px;
            }

            /* Buttons side by side and smaller */
            .button-group {
                flex-direction: row;
                gap: 8px;
            }

            .btn {
                flex: 0 1 auto;
                padding: 8px 16px;
                font-size: 0.8em;
            }

            .btn-compact {
                padding: 8px 12px;
                font-size: 0.75em;
            }

            /* Show short text on mobile, hide full text */
            .btn-text-full {
                display: none;
            }

            .btn-text-short {
                display: inline;
            }

            /* Compact mode toggle on mobile */
            .mode-toggle-container {
                margin-bottom: 8px;
                gap: 6px;
            }

            .mode-toggle-label {
                display: none; /* Hide label on mobile */
            }

            .mode-option {
                padding: 6px 14px;
                font-size: 0.8em;
            }

            /* Hide stats */
            .stats {
                display: none;
            }

            /* Compact results header - single line */
            .results-header {
                flex-direction: row;
                align-items: center;
                gap: 10px;
                margin-bottom: 10px;
            }

            .results h2 {
                font-size: 1em;
                margin: 0;
            }

            .translation-count {
                font-size: 0.85em;
                padding: 3px 10px;
            }

            .export-btn {
                font-size: 0.8em;
                padding: 6px 12px;
                margin-left: 6px;
            }

            /* Compact audio level display */
            .audio-level-container {
                margin: 0 15px 10px 15px;
                padding: 8px;
                flex-direction: row;
                gap: 10px;
            }

            .gain-control-container {
                display: none; /* Hide gain control on mobile */
            }

            .audio-level-label {
                min-width: auto;
                font-size: 0.85em;
                white-space: nowrap;
            }

            .audio-level-meter {
                height: 15px;
            }

            .results {
                padding: 15px;
            }

            /* Simplified translation display for mobile */
            .translation-item {
                padding: 12px;
                margin-bottom: 8px;
            }

            /* For ALL translations on mobile - show only English */
            .translation-item .original {
                display: none !important;
            }

            .translation-item .translated {
                display: block !important;
                font-size: 1.1em;
                line-height: 1.6;
            }

            /* Make final (white) translations slightly bolder */
            .translation-item:not(.interim) .translated {
                font-weight: 500;
            }

            .interim-box {
                padding: 10px;
                margin-bottom: 10px;
            }

            .interim-label {
                font-size: 0.7em;
            }

            .interim-text {
                font-size: 0.95em;
            }

            /* Speed control mobile adjustments */
            .control-group-inline {
                width: auto;
                flex: 0 1 auto;
                margin-top: 0;
                padding: 4px 8px;
                gap: 4px;
            }

            .control-group-inline label {
                font-size: 0.7em !important;
                margin-right: 2px !important;
                white-space: nowrap;
            }

            .speed-select {
                font-size: 0.7em;
                padding: 4px 8px;
                min-width: 50px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üåê BudgetTranslate <span style="color: #999; font-size: 0.4em; font-weight: normal;">v1</span></h1>
            <p>Real-time Speech Translation powered by Google Cloud</p>
            <div class="badge">No Timeout ‚Ä¢ Unlimited Duration</div>
            <div style="margin-top: 10px;">
                <a href="/billing" style="color: white; text-decoration: none; background: rgba(255,255,255,0.2); padding: 8px 16px; border-radius: 5px; font-size: 0.9em;" target="_blank">üí∞ View Billing</a>
            </div>
        </div>

        <div id="status" class="status ready">
            Ready to start
        </div>

        <div class="controls">
            <div class="control-row">
                <div class="control-group">
                    <label for="audioSource">Audio Source</label>
                    <select id="audioSource">
                        <option value="microphone">üé§ Microphone</option>
                        <option value="system">üñ•Ô∏è System Audio (Tab/Screen)</option>
                    </select>
                </div>
            </div>

            <div class="control-row">
                <div class="control-group">
                    <label for="sourceLanguage">Source Language (Speech)</label>
                    <select id="sourceLanguage">
                        <option value="ro-RO">Romanian</option>
                        <option value="en-US">English</option>
                        <option value="es-ES">Spanish</option>
                        <option value="fr-FR">French</option>
                        <option value="de-DE">German</option>
                        <option value="it-IT">Italian</option>
                        <option value="pt-PT">Portuguese</option>
                        <option value="ru-RU">Russian</option>
                        <option value="ja-JP">Japanese</option>
                        <option value="zh-CN">Chinese (Simplified)</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="targetLanguage">Target Language (Translation)</label>
                    <select id="targetLanguage">
                        <option value="en">English</option>
                        <option value="ro">Romanian</option>
                        <option value="es">Spanish</option>
                        <option value="fr">French</option>
                        <option value="de">German</option>
                        <option value="it">Italian</option>
                        <option value="pt">Portuguese</option>
                        <option value="ru">Russian</option>
                        <option value="ja">Japanese</option>
                        <option value="zh">Chinese</option>
                    </select>
                </div>
            </div>

            <div class="mode-toggle-container">
                <span class="mode-toggle-label">Translation Mode:</span>
                <div class="mode-toggle">
                    <button class="mode-option active" data-mode="talks" data-interval="6000">Talks (6s)</button>
                    <button class="mode-option" data-mode="earbuds" data-interval="6000" data-enable-tts="true">üéß EarBuds (6s)</button>
                </div>
            </div>

            <div class="button-group">
                <button id="startBtn" class="btn btn-start btn-compact">
                    <span class="btn-text-full">üé§ Start</span>
                    <span class="btn-text-short">üé§ Start</span>
                </button>
                <button id="stopBtn" class="btn btn-stop btn-compact" disabled>
                    ‚èπÔ∏è Stop
                </button>
                <div class="control-group-inline" id="ttsRateContainer" style="display: none;">
                    <label for="ttsRate" style="font-size: 0.9em; margin-right: 5px; margin-bottom: 0;">Speech Rate:</label>
                    <select id="ttsRate" class="speed-select" aria-label="Adjust translation speech rate">
                        <option value="0.7">0.7x</option>
                        <option value="0.8">0.8x</option>
                        <option value="0.9" selected>0.9x</option>
                        <option value="1.0">1.0x</option>
                        <option value="1.1">1.1x</option>
                        <option value="1.2">1.2x</option>
                        <option value="1.3">1.3x</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Voice Selection (for testing) -->
        <div class="control-row" id="voiceSelectionContainer" style="display: none; margin-top: 15px;">
            <label for="voiceSelect" style="font-size: 0.9em; margin-bottom: 5px; display: block;">üé§ Voice Selection:</label>
            <select id="voiceSelect" class="voice-select" style="width: 100%; padding: 8px; border-radius: 5px; border: 1px solid #ddd;">
                <option value="auto">Auto (Best Quality)</option>
                <option value="google-natural">Google Natural/Neural</option>
                <option value="apple-premium">Apple Premium (Siri)</option>
                <option value="cloud">Any Cloud Voice</option>
                <option value="local">Local Device Voice</option>
            </select>
        </div>

        <!-- Microphone Gain Control -->
        <div class="control-row" style="margin-top: 15px;">
            <label style="font-size: 0.9em; margin-bottom: 5px; display: flex; align-items: center; gap: 8px;">
                <span>üé§ Mic Gain: <span id="micGainValue">10.0</span>x</span>
                <label style="font-size: 0.8em; display: flex; align-items: center; gap: 4px; cursor: pointer; margin-left: auto;">
                    <input type="checkbox" id="autoGainToggle" checked>
                    Auto
                </label>
            </label>
            <input type="range" id="micGainSlider" min="1" max="20" value="10" step="0.5" style="width: 100%;">
            <div id="gainHint" style="font-size: 0.75em; color: #666; margin-top: 5px;">Auto-gain disabled (Google STT handles audio levels)</div>
        </div>

        <div class="interim-box">
            <div class="interim-label">INTERIM RESULT:</div>
            <div id="interimText" class="interim-text">Waiting for speech...</div>
        </div>

        <!-- Gain control removed - AGC (Automatic Gain Control) handles input volume automatically -->
        <!-- TTS volume is controlled by device physical volume buttons/settings -->

        <div class="audio-level-container">
            <div class="audio-level-label">üé§ AUDIO LEVEL:</div>
            <div class="audio-level-meter">
                <div id="audioLevelBar" class="audio-level-bar"></div>
            </div>
            <div id="audioLevelText" class="audio-level-text">0%</div>
        </div>

        <div class="results">
            <div class="results-header">
                <h2>Translations</h2>
                <div>
                    <span id="translationCount" class="translation-count">0 translations</span>
                    <button id="exportBtn" class="export-btn" disabled>üì• Export</button>
                </div>
            </div>
            <div id="resultsContainer">
                <div class="empty-state">
                    Click "Start Listening" and speak to see translations here
                </div>
            </div>
        </div>

        <div class="stats">
            <div class="stat-item">
                <div id="sessionTime" class="stat-value">0:00</div>
                <div class="stat-label">Session Time</div>
            </div>
            <div class="stat-item">
                <div id="wordsTranslated" class="stat-value">0</div>
                <div class="stat-label">Words Translated</div>
            </div>
        </div>
    </div>

    <script>
        // Unicode sanitization function to prevent formatting-based attacks
        // Compile regex once for performance
        const SANITIZE_REGEX = /[\u202E\u202D\u202C\u200E\u200F\u200B-\u200D\uFEFF\u0000-\u001F\u007F-\u009F]/g;

        function sanitizeText(text) {
            if (!text) return '';
            return text.replace(SANITIZE_REGEX, '').trim();
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        class GTranslateV4Client {
            constructor() {
                this.socket = null;
                this.recognition = null;
                this.audioContext = null;
                this.mediaStream = null;
                this.processor = null;
                this.isRecording = false;
                this.translationCount = 0;
                this.sessionStartTime = null;
                this.sessionTimer = null;
                this.wordsTranslated = 0;
                this.audioChunkBuffer = [];
                this.audioBufferSize = 4096;
                this.translationInterval = 6000; // Default: 6 seconds
                this.interimElements = new Set(); // Track interim DOM elements for fast removal
                this.audioWorkletLoaded = false; // Prevent loading module multiple times
                this.lastTranslation = ''; // Store last translated text for EarBuds/TTS display
                this.lastTranslationTime = 0; // Timestamp of last translation update
                this.lastEarbudsInterimSpoken = '';
                this.wakeLockHeartbeat = null;

                // Network quality monitoring
                this.pingStartTime = null;
                this.latency = 0;
                this.latencyHistory = [];

                // Session export data
                this.sessionTranslations = [];
                this.MAX_SESSION_TRANSLATIONS = 1000; // Prevent memory exhaustion

                // Mode tracking
                this.currentMode = 'talks'; // Default mode: talks or earbuds

                // Text-to-Speech
                this.ttsEnabled = false;
                this.speechSynthesis = window.speechSynthesis;
                this.currentUtterance = null;
                this.ttsQueue = []; // Queue for pending translations to speak
                this.isSpeaking = false; // Track if currently speaking
                this.speechRate = 0.9; // Default speech rate (slower = less anxious/rushed)
                this.voicePreference = 'auto'; // Voice selection preference ('auto' or voice name)
                this.selectedVoice = null; // Actual voice object when user selects specific voice
                this.voiceCache = new Map(); // Cache voices by language for fast lookup
                this.recentlySpoken = []; // Track recently spoken text with timestamps (for duplicate detection)
                this.lastDedupCleanup = 0; // Last time we cleaned up recentlySpoken array

                // Load saved voice preference from localStorage
                const savedVoicePreference = localStorage.getItem('gtranslate_voice_preference');
                if (savedVoicePreference) {
                    this.voicePreference = savedVoicePreference;
                    console.log(`üé§ Loaded saved voice preference: ${this.voicePreference}`);
                }

                // Screen Wake Lock (keep screen on during recording)
                this.wakeLock = null;

                // Initialize voice cache (handle race condition)
                if (this.speechSynthesis) {
                    // Handle voiceschanged event (fires when voices are loaded)
                    this.speechSynthesis.addEventListener('voiceschanged', () => {
                        console.log('üé§ voiceschanged event fired');
                        this.buildVoiceCache();
                    });

                    // Try immediate load (works in Safari/Firefox, fails in Chrome/Edge)
                    const immediateVoices = this.speechSynthesis.getVoices();
                    if (immediateVoices.length > 0) {
                        console.log('üé§ Voices available immediately:', immediateVoices.length);
                        this.buildVoiceCache();
                    } else {
                        console.log('üé§ Voices not loaded yet, waiting for voiceschanged event...');
                    }
                }

                // Check browser compatibility on startup
                this.checkBrowserCompatibility();

                this.initElements();
                this.initSocket();
                this.initModeToggle();
            }

            checkBrowserCompatibility() {
                const issues = [];

                if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                    issues.push('‚ùå Web Speech API not supported ‚Äî please use Chrome or Edge');
                }

                if (typeof WebSocket === 'undefined') {
                    issues.push('‚ùå WebSocket not supported');
                }

                const ua = navigator.userAgent;
                const isChrome = /Chrome/.test(ua) && /Google Inc/.test(navigator.vendor);
                const isEdge = /Edg/.test(ua);

                if (!isChrome && !isEdge) {
                    issues.push('‚ö†Ô∏è For best results, use Chrome or Edge (Web Speech API works best there)');
                }

                if (issues.length > 0) {
                    console.warn('Browser compatibility issues:', issues);
                    const hasErrors = issues.some(i => i.startsWith('‚ùå'));
                    if (hasErrors) {
                        alert('Browser compatibility issue:\n\n' + issues.join('\n'));
                    }
                }
            }

            initElements() {
                this.startBtn = document.getElementById('startBtn');
                this.stopBtn = document.getElementById('stopBtn');
                this.audioSource = document.getElementById('audioSource');
                this.sourceLanguage = document.getElementById('sourceLanguage');
                this.targetLanguage = document.getElementById('targetLanguage');
                this.statusDiv = document.getElementById('status');
                this.interimText = document.getElementById('interimText');
                this.resultsContainer = document.getElementById('resultsContainer');
                this.translationCountEl = document.getElementById('translationCount');
                this.sessionTimeEl = document.getElementById('sessionTime');
                this.wordsTranslatedEl = document.getElementById('wordsTranslated');
                this.audioLevelBar = document.getElementById('audioLevelBar');
                this.audioLevelText = document.getElementById('audioLevelText');
                this.exportBtn = document.getElementById('exportBtn');
                this.ttsRateContainer = document.getElementById('ttsRateContainer');
                this.ttsRateSelect = document.getElementById('ttsRate');
                this.voiceSelectionContainer = document.getElementById('voiceSelectionContainer');
                this.voiceSelect = document.getElementById('voiceSelect');
                this.micGainSlider = document.getElementById('micGainSlider');
                this.micGainValue = document.getElementById('micGainValue');
                this.autoGainToggle = document.getElementById('autoGainToggle');
                this.gainHint = document.getElementById('gainHint');

                this.startBtn.addEventListener('click', () => this.startRecording());
                this.stopBtn.addEventListener('click', () => this.stopRecording());
                this.exportBtn.addEventListener('click', () => this.exportSession());

                // Re-acquire wake lock when page becomes visible again
                document.addEventListener('visibilitychange', async () => {
                    if (!document.hidden && this.isRecording && 'wakeLock' in navigator) {
                        // Page became visible again while recording - re-acquire wake lock
                        console.log('üì± Page visible again - re-acquiring wake lock');
                        try {
                            await this.requestWakeLock();
                        } catch (err) {
                            console.warn('‚ö†Ô∏è Could not re-acquire wake lock on visibility change:', err.message);
                        }
                    }
                });

                // TTS rate control (dropdown)
                this.ttsRateSelect.addEventListener('change', (e) => {
                    this.speechRate = parseFloat(e.target.value);
                    console.log(`üîä Speech rate set to ${this.speechRate.toFixed(1)}x`);
                });

                // Voice selection control
                this.voiceSelect.addEventListener('change', (e) => {
                    const selectedValue = e.target.value;

                    // Log all available voices
                    const allVoices = this.speechSynthesis.getVoices();

                    if (selectedValue === 'auto') {
                        // Auto mode - let system choose best voice
                        this.voicePreference = 'auto';
                        this.selectedVoice = null;
                    } else {
                        // Specific voice selected - store the voice object
                        const voice = allVoices.find(v => v.name === selectedValue);
                        if (voice) {
                            this.voicePreference = selectedValue; // Store voice name
                            this.selectedVoice = voice; // Store voice object
                        } else {
                            this.voicePreference = 'auto';
                            this.selectedVoice = null;

                            // Notify user via console about voice selection failure
                            console.warn(`‚ö†Ô∏è Selected voice not available. Falling back to AUTO mode.`);
                        }
                    }

                    // Save voice preference to localStorage
                    try {
                        localStorage.setItem('gtranslate_voice_preference', this.voicePreference);
                        console.log(`üé§ Voice selection saved: ${this.voicePreference}`);
                    } catch (error) {
                        console.error(`‚ùå Failed to save voice preference to localStorage:`, error);
                    }
                });

                // Target language change - update voice dropdown
                this.targetLanguage.addEventListener('change', () => {
                    // Re-populate voice dropdown for new language
                    this.populateVoiceDropdown();

                    // Reset voice selection to auto when language changes
                    if (this.voiceSelect) {
                        this.voiceSelect.value = 'auto';
                        this.voicePreference = 'auto';
                        this.selectedVoice = null;

                        try {
                            localStorage.setItem('gtranslate_voice_preference', 'auto');
                        } catch (error) {
                            console.error(`‚ùå Failed to update localStorage:`, error);
                        }
                    }
                });

                // Microphone gain control ‚Äî manual slider
                this.micGainSlider.addEventListener('input', (e) => {
                    const gain = parseFloat(e.target.value);
                    this.micGainValue.textContent = gain.toFixed(1);

                    // Disable auto-gain when user manually adjusts slider
                    if (this.autoGainToggle.checked) {
                        this.autoGainToggle.checked = false;
                        this.micGainSlider.disabled = false;
                        this.gainHint.textContent = 'Manual gain mode';
                    }

                    // Update both the Web Audio gain node AND the AudioWorklet gain
                    if (this.gainNode) {
                        this.gainNode.gain.value = gain;
                    }

                    // Send new gain to AudioWorklet (this also disables auto-gain in worklet)
                    if (this.processor && this.processor.port) {
                        this.processor.port.postMessage({ command: 'setGain', value: gain });
                    }

                    console.log(`üé§ Microphone gain manually set to ${gain.toFixed(1)}x`);
                });

                // Auto-gain toggle
                this.autoGainToggle.addEventListener('change', (e) => {
                    const autoEnabled = e.target.checked;
                    this.micGainSlider.disabled = autoEnabled;
                    this.gainHint.textContent = autoEnabled
                        ? 'Auto-gain enabled: level adjusts automatically'
                        : 'Manual gain mode';

                    if (this.processor && this.processor.port) {
                        this.processor.port.postMessage({ command: 'setAutoGain', value: autoEnabled });
                    }

                    console.log(`üé§ Auto-gain ${autoEnabled ? 'enabled' : 'disabled'}`);
                });

                // Initialize slider state based on auto-gain default
                this.micGainSlider.disabled = this.autoGainToggle.checked;
            }

            initSocket() {
                // Configure Socket.IO with reconnection settings
                this.socket = io({
                    reconnection: true,
                    reconnectionAttempts: 5,
                    reconnectionDelay: 1000,
                    timeout: 10000
                });

                this.socket.on('connect', () => {
                    console.log('‚úÖ Connected to server');
                    this.updateStatus('Ready to start', 'ready');
                    this.startLatencyMonitoring();
                });

                // Latency monitoring with ping/pong
                this.socket.on('pong', () => {
                    if (this.pingStartTime) {
                        this.latency = Date.now() - this.pingStartTime;
                        this.latencyHistory.push(this.latency);

                        // Keep only last 10 measurements
                        if (this.latencyHistory.length > 10) {
                            this.latencyHistory.shift();
                        }

                        const avgLatency = this.latencyHistory.reduce((a, b) => a + b, 0) / this.latencyHistory.length;

                        console.log(`üì° Network latency: ${this.latency}ms (avg: ${avgLatency.toFixed(0)}ms)`);

                        // Warn if latency is high
                        if (avgLatency > 500) {
                            console.warn('‚ö†Ô∏è High latency detected, audio quality may be affected');
                        }
                    }
                });

                this.socket.on('disconnect', (reason) => {
                    console.log('‚ùå Disconnected from server:', reason);
                    this.updateStatus('Disconnected from server', 'error');

                    // Auto-stop recording if disconnected during session
                    if (this.isRecording) {
                        this.stopRecording();
                    }
                });

                this.socket.on('connect_error', (error) => {
                    console.error('Connection error:', error);
                    this.updateStatus('Cannot connect to server', 'error');
                });

                this.socket.on('reconnect_attempt', (attemptNumber) => {
                    console.log(`Reconnection attempt ${attemptNumber}...`);
                    this.updateStatus(`Reconnecting... (${attemptNumber}/5)`, 'error');
                });

                this.socket.on('reconnect_failed', () => {
                    console.error('Reconnection failed');
                    this.updateStatus('Connection failed. Please refresh the page.', 'error');
                    if (this.isRecording) {
                        this.stopRecording();
                    }
                });

                // Handle server-side connection rejection
                this.socket.on('connection-error', (data) => {
                    console.error('Connection rejected:', data.message);
                    this.updateStatus(data.message, 'error');
                    alert(data.message); // Show alert for critical connection issues
                });

                // Handle session timeout
                this.socket.on('session-timeout', (data) => {
                    console.warn('Session timeout:', data.message);
                    this.updateStatus(data.message, 'error');
                    alert(`Session expired: ${data.message}`);
                    if (this.isRecording) {
                        this.stopRecording();
                    }
                });

                this.socket.on('session-started', (data) => {
                    console.log('üé§ Session started', data);
                    this.updateStatus('Listening...', 'listening');

                    // Store source language for billing tracking
                    this.currentSourceLanguage = data.sourceLanguage;
                });

                this.socket.on('interim-result', (data) => {
                    const sourceText = sanitizeText(data.text);

                    if (this.ttsEnabled || this.currentMode === 'earbuds') {
                        const hasRecentTranslation = this.lastTranslation &&
                            (Date.now() - this.lastTranslationTime < 20000);

                        if (hasRecentTranslation) {
                            this.interimText.textContent = `${this.lastTranslation}...`;
                        } else {
                            this.interimText.textContent = 'Listening...';
                        }
                    } else {
                        this.interimText.textContent = sourceText || 'Listening...';
                    }
                });

                this.socket.on('translation-result', (data) => {
                    console.log('üì• TRANSLATION RECEIVED!', data);

                    if (data.translated) {
                        this.lastTranslation = sanitizeText(data.translated);
                        this.lastTranslationTime = Date.now();
                    }

                    this.addTranslation(data);

                    // Track translation usage for billing
                    if (data.translated && this.currentSourceLanguage) {
                        const charCount = data.translated.length;
                        // Assume glossary is used if available (you could enhance this with actual glossary status)
                        const useGlossary = false; // Set to true when glossary is confirmed enabled

                        if (useGlossary) {
                            this.trackBilling('glossary', charCount, this.currentSourceLanguage);
                        } else {
                            this.trackBilling('translation', charCount, this.currentSourceLanguage);
                        }
                    }
                });

                this.socket.on('session-stopped', (data) => {
                    console.log('‚èπÔ∏è Session stopped', data);
                });

                this.socket.on('recognition-error', (error) => {
                    console.error('Recognition error:', error);
                    const errorMsg = error.message || JSON.stringify(error);
                    const errorCode = error.code ? String(error.code) : '';

                    // Don't show errors for auto-restart events (server handles it)
                    if (!errorCode || (!errorCode.includes('STREAM_ENDED') && !errorCode.includes('STREAM_CLOSED'))) {
                        this.updateStatus(`‚ö†Ô∏è ${errorMsg}`, 'error');

                        // Auto-stop only for fatal errors, not stream restarts
                        if (errorCode && errorCode.includes('DESTROYED')) {
                            console.warn('Stream is dead, stopping recording');
                            if (this.isRecording) {
                                this.stopRecording();
                            }
                        }
                    } else {
                        console.log('Stream restarting...', errorCode);
                    }
                });

                this.socket.on('translation-error', (error) => {
                    console.error('Translation error:', error);
                });
            }

            initModeToggle() {
                const modeOptions = document.querySelectorAll('.mode-option');

                modeOptions.forEach(option => {
                    option.addEventListener('click', () => {
                        // Remove active class from all options
                        modeOptions.forEach(opt => opt.classList.remove('active'));

                        // Add active class to clicked option
                        option.classList.add('active');

                        // Update current mode
                        this.currentMode = option.dataset.mode;

                        // Update translation interval
                        this.translationInterval = parseInt(option.dataset.interval);

                        // Handle TTS auto-enable for EarBuds mode
                        const enableTTS = option.dataset.enableTts === 'true';
                        this.ttsEnabled = enableTTS;

                        // Show/hide TTS rate control and voice selection based on TTS state
                        if (this.ttsRateContainer) {
                            this.ttsRateContainer.style.display = enableTTS ? 'flex' : 'none';
                        }
                        if (this.voiceSelectionContainer) {
                            this.voiceSelectionContainer.style.display = enableTTS ? 'block' : 'none';
                        }

                        // Stop any currently playing speech if TTS is being disabled
                        if (!enableTTS && this.speechSynthesis) {
                            this.speechSynthesis.cancel();
                            this.ttsQueue = [];
                            this.isSpeaking = false;
                        }

                        console.log(`Mode changed: ${this.currentMode}, Interval: ${this.translationInterval}ms, TTS: ${enableTTS}`);
                    });
                });
            }

            async requestWakeLock() {
                // Request screen wake lock to keep screen on during recording
                // Critical for mobile EarBuds mode where user listens with screen off
                if ('wakeLock' in navigator) {
                    try {
                        this.wakeLock = await navigator.wakeLock.request('screen');
                        console.log('üîí Screen wake lock acquired - screen will stay on');
                        this.startWakeLockHeartbeat();

                        // Re-acquire wake lock automatically if it's released
                        this.wakeLock.addEventListener('release', async () => {
                            console.log('üîì Wake lock released - attempting to re-acquire');

                            // Only re-acquire if we're still recording
                            if (this.isRecording) {
                                try {
                                    await this.requestWakeLock();
                                    console.log('üîí Wake lock re-acquired successfully');
                                } catch (err) {
                                    console.warn('‚ö†Ô∏è Could not re-acquire wake lock:', err.message);
                                }
                            }
                        });
                    } catch (err) {
                        console.warn('‚ö†Ô∏è Could not acquire wake lock:', err.message);
                        // Non-fatal - continue without wake lock

                        // Warn user on mobile if wake lock fails
                        if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
                            this.updateStatus('‚ö†Ô∏è Screen may turn off - keep phone unlocked', 'warning');
                        }
                    }
                } else {
                    console.log('‚ÑπÔ∏è Wake Lock API not supported on this device');

                    // Warn mobile users that screen must stay on
                    if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
                        this.updateStatus('‚ö†Ô∏è Keep screen on - app will stop if screen locks', 'warning');
                        setTimeout(() => {
                            this.updateStatus('Listening...', 'listening');
                        }, 5000);
                    }
                }
            }

            startWakeLockHeartbeat() {
                if (this.wakeLockHeartbeat || !('wakeLock' in navigator)) {
                    return;
                }

                this.wakeLockHeartbeat = setInterval(async () => {
                    if (!this.isRecording) {
                        this.stopWakeLockHeartbeat();
                        return;
                    }

                    if (!this.wakeLock) {
                        try {
                            await this.requestWakeLock();
                        } catch (err) {
                            console.warn('‚ö†Ô∏è Wake lock heartbeat failed:', err.message);
                        }
                    }
                }, 45000); // Retry roughly every 45 seconds
            }

            stopWakeLockHeartbeat() {
                if (this.wakeLockHeartbeat) {
                    clearInterval(this.wakeLockHeartbeat);
                    this.wakeLockHeartbeat = null;
                }
            }

            async releaseWakeLock() {
                if (this.wakeLock) {
                    try {
                        await this.wakeLock.release();
                        this.wakeLock = null;
                        console.log('üîì Screen wake lock released - screen can turn off');
                    } catch (err) {
                        console.warn('‚ö†Ô∏è Error releasing wake lock:', err);
                    }
                }

                this.stopWakeLockHeartbeat();
            }

            async startRecording() {
                try {
                    // Request wake lock to keep screen on (critical for mobile EarBuds mode)
                    await this.requestWakeLock();

                    // Validate inputs before starting
                    const sourceLanguage = this.sourceLanguage.value;
                    const targetLang = this.targetLanguage.value;
                    const audioSourceType = this.audioSource.value;

                    // Input validation
                    if (!sourceLanguage || !targetLang) {
                        throw new Error('Please select both source and target languages');
                    }

                    const validLanguageCodes = /^[a-z]{2}-[A-Z]{2}$/;
                    const validTargetLanguages = /^[a-z]{2}(-[A-Z]{2})?$/;

                    if (!validLanguageCodes.test(sourceLanguage)) {
                        throw new Error('Invalid source language code');
                    }

                    if (!validTargetLanguages.test(targetLang)) {
                        throw new Error('Invalid target language code');
                    }

                    if (typeof this.translationInterval !== 'number' || this.translationInterval < 1000 || this.translationInterval > 60000) {
                        throw new Error('Invalid translation interval');
                    }

                    if (!['microphone', 'system'].includes(audioSourceType)) {
                        throw new Error('Invalid audio source');
                    }

                    // Start Web Speech API recognition
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    if (!SpeechRecognition) {
                        throw new Error('Web Speech API not supported. Please use Chrome or Edge.');
                    }

                    this.recognition = new SpeechRecognition();
                    this.recognition.lang = sourceLanguage || 'ro-RO';
                    this.recognition.continuous = true;
                    this.recognition.interimResults = true;
                    this.recognition.maxAlternatives = 1;

                    this.recognition.onresult = (event) => {
                        if (!this.isRecording) return;
                        for (let i = event.resultIndex; i < event.results.length; i++) {
                            const transcript = event.results[i][0].transcript;
                            const isFinal = event.results[i].isFinal;
                            this.socket.emit('transcript-result', { text: transcript, isFinal });
                        }
                    };

                    this.recognition.onend = () => {
                        // Chrome cuts off after ~60s ‚Äî auto-restart if still recording
                        if (this.isRecording) {
                            console.log('üîÑ Web Speech API ended, restarting...');
                            try { this.recognition.start(); } catch(e) { console.warn('Restart failed:', e); }
                        }
                    };

                    this.recognition.onerror = (event) => {
                        console.error('Web Speech API error:', event.error);
                        if (event.error === 'not-allowed') {
                            this.updateStatus('‚ùå Microphone permission denied', 'error');
                            this.stopRecording();
                        } else if (event.error !== 'no-speech' && event.error !== 'aborted') {
                            console.warn('Speech recognition error:', event.error);
                        }
                    };

                    this.recognition.start();
                    console.log('üé§ Web Speech API started (lang: ' + this.recognition.lang + ')');

                    // Tell server to initialize translation session
                    this.socket.emit('start-session', {
                        sourceLanguage: sourceLanguage,
                        targetLang: targetLang,
                        mode: this.currentMode
                    });

                    this.isRecording = true;
                    this.translationCount = 0;
                    this.wordsTranslated = 0;
                    this.resultsContainer.innerHTML = '';
                    this.startBtn.disabled = true;
                    this.stopBtn.disabled = false;
                    this.audioSource.disabled = true;
                    this.sourceLanguage.disabled = true;
                    this.targetLanguage.disabled = true;

                    this.startSessionTimer();

                } catch (error) {
                    console.error('Failed to start recording:', error);
                    this.updateStatus(`Error: ${error.message}`, 'error');
                }
            }

            stopRecording() {
                this.isRecording = false;

                // Track STT usage for billing
                if (this.sttStartTime && this.currentSourceLanguage) {
                    const sttDurationMs = Date.now() - this.sttStartTime;
                    const sttMinutes = sttDurationMs / 60000;
                    this.trackBilling('stt', sttMinutes, this.currentSourceLanguage);
                    this.sttStartTime = null;
                }

                // Release wake lock - screen can turn off now
                this.releaseWakeLock();

                if (this.recognition) {
                    this.recognition.onend = null; // Prevent auto-restart
                    this.recognition.stop();
                    this.recognition = null;
                }

                this.socket.emit('stop-session');

                this.startBtn.disabled = false;
                this.stopBtn.disabled = true;
                this.audioSource.disabled = false;
                this.sourceLanguage.disabled = false;
                this.targetLanguage.disabled = false;

                this.stopSessionTimer();
                this.updateStatus('Ready to start', 'ready');
                this.interimText.textContent = 'Waiting for speech...';
                this.lastTranslation = '';
                this.lastTranslationTime = 0;

                // Stop any playing speech and clear queue
                if (this.speechSynthesis) {
                    this.speechSynthesis.cancel();
                    this.ttsQueue = []; // Clear pending translations
                    this.isSpeaking = false;
                    console.log('üîá TTS stopped and queue cleared');
                }
            }

            addTranslation(data) {
                // Server-side duplicate detection handles dedup (3 layers in translation-rules-engine)
                // Client-side dedup removed to avoid silently dropping legitimate translations

                // Display translations on screen (ALL modes including EarBuds)
                this.translationCount++;
                this.wordsTranslated += data.original.split(/\s+/).length;

                this.translationCountEl.textContent = `${this.translationCount} translations`;
                this.wordsTranslatedEl.textContent = this.wordsTranslated;

                // Store translation for export (only final translations)
                if (!data.isInterim) {
                    this.sessionTranslations.push({
                        timestamp: new Date().toISOString(),
                        original: data.original,
                        translated: data.translated
                    });

                    // Prevent memory exhaustion with auto-export
                    if (this.sessionTranslations.length > this.MAX_SESSION_TRANSLATIONS) {
                        console.warn(`‚ö†Ô∏è Session translation limit reached (${this.MAX_SESSION_TRANSLATIONS}), auto-exporting oldest 500...`);

                        // Export oldest 500 to file
                        const oldTranslations = this.sessionTranslations.splice(0, 500);
                        this.exportPartialSession(oldTranslations);
                    }

                    // Enable export button once we have translations
                    this.exportBtn.disabled = false;

                    // Speak final translations only (EarBuds auto-enables TTS)
                    this.lastEarbudsInterimSpoken = '';
                    this.speakTranslation(data.translated, this.targetLanguage.value);
                }

                // If this is a final translation (not interim), clear all previous interim translations
                if (!data.isInterim) {
                    this.clearInterimTranslations();
                }

                // EarBuds mode: Audio-first, skip visual translation cards (only show STT interim text)
                if (this.currentMode === 'earbuds') {
                    return; // Skip visual display in EarBuds mode
                }

                // Use template literals for faster HTML construction
                const item = document.createElement('div');
                item.className = data.isInterim ? 'translation-item interim' : 'translation-item';

                item.innerHTML = `
                    <div class="original">üìù ${escapeHtml(sanitizeText(data.original))}</div>
                    <div class="translated">üí¨ ${escapeHtml(sanitizeText(data.translated))}</div>
                `;

                // Track interim elements for fast removal
                if (data.isInterim) {
                    this.interimElements.add(item);
                }

                // Use fragment to batch DOM operations
                const fragment = document.createDocumentFragment();
                fragment.appendChild(item);
                this.resultsContainer.insertBefore(fragment, this.resultsContainer.firstChild);

                // Limit DOM size to prevent performance degradation
                const maxItems = 50;
                while (this.resultsContainer.children.length > maxItems) {
                    const lastChild = this.resultsContainer.lastChild;
                    // Remove from interim tracking if applicable
                    this.interimElements.delete(lastChild);
                    this.resultsContainer.removeChild(lastChild);
                }
            }

            clearInterimTranslations() {
                // O(n) removal without DOM queries
                this.interimElements.forEach(element => {
                    if (element.parentNode) {
                        element.parentNode.removeChild(element);
                    }
                });
                this.interimElements.clear();
            }

            startSessionTimer() {
                this.sessionStartTime = Date.now();
                this.sessionTimer = setInterval(() => {
                    const elapsed = Math.floor((Date.now() - this.sessionStartTime) / 1000);
                    const minutes = Math.floor(elapsed / 60);
                    const seconds = elapsed % 60;
                    this.sessionTimeEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                }, 1000);
            }

            stopSessionTimer() {
                if (this.sessionTimer) {
                    clearInterval(this.sessionTimer);
                    this.sessionTimer = null;
                }
            }

            updateStatus(message, type) {
                this.statusDiv.textContent = message;
                this.statusDiv.className = `status ${type}`;
            }

            startLatencyMonitoring() {
                // Ping server every 5 seconds to measure latency
                this.latencyMonitorInterval = setInterval(() => {
                    this.pingStartTime = Date.now();
                    this.socket.emit('ping');
                }, 5000);
            }

            stopLatencyMonitoring() {
                if (this.latencyMonitorInterval) {
                    clearInterval(this.latencyMonitorInterval);
                    this.latencyMonitorInterval = null;
                }
            }

            async trackBilling(type, amount, language) {
                // Send billing data to API for persistent storage in database
                try {
                    const response = await fetch('/api/billing/track', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ type, amount, language })
                    });

                    if (response.ok) {
                        console.log(`üí∞ Billing tracked: ${type} = ${amount.toFixed(2)} for ${language || 'unknown'}`);
                    } else {
                        console.warn('Failed to track billing:', await response.text());
                    }
                } catch (e) {
                    console.warn('Failed to track billing:', e);
                }

                // Also update localStorage as a backup/cache (for offline viewing)
                try {
                    const billingData = JSON.parse(localStorage.getItem('gtranslate_billing_session') || '{}');

                    // Initialize if needed
                    if (!billingData.languages) {
                        billingData.languages = {};
                        billingData.sttMinutes = 0;
                        billingData.translationChars = 0;
                        billingData.glossaryChars = 0;
                        billingData.startTime = Date.now();
                    }

                    // Update totals
                    switch(type) {
                        case 'stt':
                            billingData.sttMinutes = (billingData.sttMinutes || 0) + amount;
                            break;
                        case 'translation':
                            billingData.translationChars = (billingData.translationChars || 0) + amount;
                            break;
                        case 'glossary':
                            billingData.glossaryChars = (billingData.glossaryChars || 0) + amount;
                            break;
                    }

                    // Update per-language
                    if (language) {
                        if (!billingData.languages[language]) {
                            billingData.languages[language] = {
                                sttMinutes: 0,
                                translationChars: 0,
                                glossaryChars: 0
                            };
                        }

                        switch(type) {
                            case 'stt':
                                billingData.languages[language].sttMinutes += amount;
                                break;
                            case 'translation':
                                billingData.languages[language].translationChars += amount;
                                break;
                            case 'glossary':
                                billingData.languages[language].glossaryChars += amount;
                                break;
                        }
                    }

                    localStorage.setItem('gtranslate_billing_session', JSON.stringify(billingData));
                } catch (e) {
                    console.warn('Failed to update localStorage billing:', e);
                }
            }

            exportSession() {
                if (this.sessionTranslations.length === 0) {
                    alert('No translations to export');
                    return;
                }

                // Create export data
                const exportData = {
                    sessionDate: new Date().toISOString(),
                    translationCount: this.sessionTranslations.length,
                    wordsTranslated: this.wordsTranslated,
                    translations: this.sessionTranslations
                };

                // Generate filename
                const dateStr = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
                const filename = `gtranslate-session-${dateStr}.json`;

                // Create blob and download
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.style.display = 'none';
                document.body.appendChild(a);
                a.click();

                // Cleanup with delay to ensure download starts
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);

                console.log(`‚úÖ Session exported: ${filename} (${this.sessionTranslations.length} translations)`);
            }

            exportPartialSession(translations) {
                const exportData = {
                    sessionDate: new Date().toISOString(),
                    translationCount: translations.length,
                    isPartialExport: true,
                    note: 'Auto-exported due to reaching session limit',
                    translations: translations
                };

                const dateStr = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
                const filename = `gtranslate-partial-${dateStr}.json`;

                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.style.display = 'none';
                document.body.appendChild(a);
                a.click();

                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);

                console.log(`üì¶ Partial session auto-exported: ${filename} (${translations.length} translations)`);
            }

            speakTranslation(text, targetLanguage, options = {}) {
                const { recordHistory = true } = options;
                if (!this.ttsEnabled || !this.speechSynthesis) {
                    return;
                }

                // Normalize text for comparison (trim whitespace, lowercase)
                const normalizedText = text.trim().toLowerCase();

                // Skip empty text
                if (normalizedText.length === 0) {
                    return;
                }

                // Clean up old entries periodically (not on every call for performance)
                const now = Date.now();
                const safeInterval = (typeof this.translationInterval === 'number' && this.translationInterval > 0)
                    ? this.translationInterval
                    : 10000;
                const DEDUP_WINDOW_MS = Math.max(safeInterval * 2, 12000);

                if (!this.lastDedupCleanup || now - this.lastDedupCleanup > 5000 || this.recentlySpoken.length > 50) {
                    this.recentlySpoken = this.recentlySpoken.filter(entry =>
                        now - entry.timestamp < DEDUP_WINDOW_MS
                    );
                    this.lastDedupCleanup = now;
                }

                // Check for duplicates in recently spoken
                const isDuplicate = this.recentlySpoken.some(entry => {
                    // Exact match
                    if (entry.text === normalizedText) {
                        console.log(`‚è≠Ô∏è [DEDUP] Exact match - skipping`);
                        return true;
                    }

                    // Only apply substring checks if both texts are substantial (>= 10 chars)
                    const bothSubstantial = entry.text.length >= 10 && normalizedText.length >= 10;

                    if (bothSubstantial) {
                        // New text is subset of old (old contains new)
                        if (entry.text.includes(normalizedText)) {
                            console.log(`‚è≠Ô∏è [DEDUP] New is substring of old - skipping`);
                            return true;
                        }

                        // Old text is subset of new (new contains old)
                        if (normalizedText.includes(entry.text)) {
                            const overlap = entry.text.length / normalizedText.length;
                            const additionalChars = normalizedText.length - entry.text.length;

                            // Block if >80% overlap AND less than 10 new characters
                            if (overlap > 0.80 && additionalChars < 10) {
                                console.log(`‚è≠Ô∏è [DEDUP] Too similar - ${(overlap*100).toFixed(0)}% overlap, +${additionalChars} chars`);
                                return true;
                            }
                        }
                    }

                    return false;
                });

                if (isDuplicate) {
                    return;
                }

                // Skip if already in queue
                const alreadyInQueue = this.ttsQueue.some(item =>
                    item.text.trim().toLowerCase() === normalizedText
                );
                if (alreadyInQueue) {
                    console.log(`‚è≠Ô∏è [DEDUP] Already in queue - skipping`);
                    return;
                }

                // Add to queue
                this.ttsQueue.push({ text, targetLanguage });

                // Add to recentlySpoken IMMEDIATELY to prevent race conditions
                if (recordHistory) {
                    this.recentlySpoken.push({
                        text: normalizedText,
                        timestamp: Date.now()
                    });
                }

                console.log(`üìù Added to TTS queue (${this.ttsQueue.length} pending): "${text.substring(0, 50)}..."`);

                // Start processing queue if not already speaking
                if (!this.isSpeaking) {
                    this.processNextInQueue();
                }
            }

            buildVoiceCache() {
                this.voiceCache.clear();
                const voices = this.speechSynthesis.getVoices();

                // Group voices by language code for instant O(1) lookup
                voices.forEach(voice => {
                    const baseLang = voice.lang.split('-')[0];

                    if (!this.voiceCache.has(voice.lang)) {
                        this.voiceCache.set(voice.lang, []);
                    }
                    if (!this.voiceCache.has(baseLang)) {
                        this.voiceCache.set(baseLang, []);
                    }

                    this.voiceCache.get(voice.lang).push(voice);
                    this.voiceCache.get(baseLang).push(voice);
                });

                console.log(`‚úÖ Voice cache built: ${this.voiceCache.size} language variants, ${voices.length} total voices`);

                // Log high-quality voices for debugging
                const highQualityVoices = voices.filter(v =>
                    v.name.includes('Neural') || v.name.includes('Wavenet') || v.name.includes('Studio') ||
                    v.name.includes('Premium') || v.name.includes('Enhanced') || v.name.includes('Natural') ||
                    (v.name.includes('Microsoft') && v.name.includes('Online')) ||
                    (v.name.includes('Google') && !v.localService)
                );
                if (highQualityVoices.length > 0) {
                    console.log(`üéôÔ∏è High-quality voices available:`, highQualityVoices.map(v => `${v.name} [${v.lang}]`));
                } else {
                    console.log(`‚ö†Ô∏è No high-quality voices detected. Available voices:`, voices.slice(0, 10).map(v => `${v.name} [${v.lang}]`));
                }

                // Update voice dropdown with available voices
                this.populateVoiceDropdown();
            }

            populateVoiceDropdown() {
                if (!this.voiceSelect) return;

                const voices = this.speechSynthesis.getVoices();

                // Log ALL available voices for debugging
                console.log(`üé§ ALL VOICES (${voices.length} total):`, voices.map(v => `${v.name} [${v.lang}] ${v.localService ? 'Local' : 'Cloud'}`));

                // Get current target language if available
                const targetLang = this.targetLanguage?.value || 'en';

                // Filter voices for current language
                const relevantVoices = voices.filter(v =>
                    v.lang.startsWith(targetLang) || v.lang.split('-')[0] === targetLang
                );

                console.log(`üé§ Found ${relevantVoices.length} voices for language: ${targetLang}`);
                console.log(`üé§ Filtered voices:`, relevantVoices.map(v => `${v.name} [${v.lang}]`));

                // Clear existing options except "Auto"
                this.voiceSelect.innerHTML = '<option value="auto">Auto (Best Quality)</option>';

                // Add ALL relevant voices (not just top 4) so user can see everything
                relevantVoices.forEach((voice) => {
                    const option = document.createElement('option');
                    option.value = voice.name;
                    option.textContent = `${voice.name} ${voice.localService ? '(Local)' : '(Cloud)'}`;
                    this.voiceSelect.appendChild(option);
                });

                console.log(`üé§ Populated dropdown with ${relevantVoices.length} voices`);

                // Restore saved voice preference if applicable
                if (this.voicePreference && this.voicePreference !== 'auto') {
                    // Try to find the saved voice in the current language's voices
                    const savedVoice = voices.find(v => v.name === this.voicePreference);
                    if (savedVoice) {
                        // Check if voice is in the dropdown (matches current language)
                        const isInDropdown = relevantVoices.some(v => v.name === this.voicePreference);
                        if (isInDropdown) {
                            this.voiceSelect.value = this.voicePreference;
                            this.selectedVoice = savedVoice;
                            console.log(`üé§ Restored saved voice: ${savedVoice.name} [${savedVoice.lang}]`);
                        } else {
                            // Saved voice doesn't match current language - reset to auto
                            console.log(`üé§ Saved voice "${this.voicePreference}" not available for ${targetLang}, resetting to auto`);
                            this.voiceSelect.value = 'auto';
                            this.voicePreference = 'auto';
                            this.selectedVoice = null;
                        }
                    }
                } else {
                    // Ensure dropdown shows "auto"
                    this.voiceSelect.value = 'auto';
                }
            }

            processNextInQueue() {
                // Check if queue is empty
                if (this.ttsQueue.length === 0) {
                    this.isSpeaking = false;
                    return;
                }

                // CRITICAL: Ensure voices are loaded before processing TTS
                let allVoices = this.speechSynthesis.getVoices();

                if (allVoices.length === 0) {
                    console.warn('‚ö†Ô∏è Voices not loaded yet, retrying in 100ms...');
                    // Don't dequeue yet - will retry
                    this.isSpeaking = false;

                    // Retry after short delay
                    setTimeout(() => {
                        if (this.ttsQueue.length > 0 && !this.isSpeaking) {
                            this.processNextInQueue();
                        }
                    }, 100);
                    return;
                }

                // Rebuild voice cache if empty (race condition protection)
                if (this.voiceCache.size === 0) {
                    console.warn('‚ö†Ô∏è Voice cache empty, rebuilding...');
                    this.buildVoiceCache();
                }

                // Get next item from queue
                const { text, targetLanguage } = this.ttsQueue.shift();
                this.isSpeaking = true;

                // Note: Already added to recentlySpoken in speakTranslation() to prevent race conditions
                // Don't add again here or we'll have duplicates in the tracking array

                // Create utterance
                const utterance = new SpeechSynthesisUtterance(text);
                this.currentUtterance = utterance;

                // Map target language codes to speech synthesis language codes
                const langMap = {
                    'en': 'en-US',
                    'en-US': 'en-US',
                    'es': 'es-ES',
                    'fr': 'fr-FR',
                    'de': 'de-DE',
                    'it': 'it-IT',
                    'pt': 'pt-PT',
                    'ru': 'ru-RU',
                    'ja': 'ja-JP',
                    'ko': 'ko-KR',
                    'zh': 'zh-CN',
                    'ar': 'ar-SA',
                    'hi': 'hi-IN',
                    'ro': 'ro-RO'
                };

                // Set language for voice
                const speechLang = langMap[targetLanguage] || targetLanguage || 'en-US';
                utterance.lang = speechLang;

                // O(1) lookup from voice cache instead of O(n) search
                const langVoices = this.voiceCache.get(speechLang) ||
                                   this.voiceCache.get(speechLang.split('-')[0]) ||
                                   [];

                // Find best voice based on user preference
                let preferredVoice;

                if (this.selectedVoice) {
                    // User selected a specific voice from dropdown - use it directly
                    preferredVoice = this.selectedVoice;
                    console.log(`üîä Using user-selected voice: ${preferredVoice.name} [${preferredVoice.lang}]`);
                } else if (this.voicePreference === 'auto') {
                    // Auto mode - prioritize most natural sounding
                    preferredVoice =
                        // Priority 1: Google Cloud voices (most natural - Neural/Wavenet/Studio)
                        langVoices.find(voice =>
                            voice.name.includes('Google') &&
                            (voice.name.includes('Neural') || voice.name.includes('Studio') || voice.name.includes('Wavenet') || voice.name.includes('Natural'))
                        ) ||
                        // Priority 2: Microsoft high-quality voices (Edge/Azure)
                        langVoices.find(voice =>
                            (voice.name.includes('Microsoft') || voice.name.includes('Edge')) &&
                            (voice.name.includes('Neural') || voice.name.includes('Online'))
                        ) ||
                        // Priority 3: Apple premium voices (macOS/iOS)
                        langVoices.find(voice =>
                            (voice.name.includes('Premium') || voice.name.includes('Enhanced')) ||
                            (voice.name.includes('Samantha') || voice.name.includes('Alex') ||
                             voice.name.includes('Karen') || voice.name.includes('Tessa') ||
                             voice.name.includes('Flo') || voice.name.includes('Grandma') ||
                             voice.name.includes('Eddy') || voice.name.includes('Reed'))
                        ) ||
                        // Priority 4: Any remote/cloud voice (usually better quality)
                        langVoices.find(voice => voice.localService === false) ||
                        // Priority 5: English-specific high quality voices
                        langVoices.find(voice =>
                            voice.name.includes('Daniel') || voice.name.includes('Moira') ||
                            voice.name.includes('Amelie') || voice.name.includes('Anna')
                        ) ||
                        // Priority 6: First available local voice
                        langVoices[0];
                } else {
                    // Fallback: try to find voice by name (for legacy saved preferences)
                    const allVoices = this.speechSynthesis.getVoices();
                    preferredVoice = allVoices.find(v => v.name === this.voicePreference);

                    // Fallback to auto selection if exact match not found
                    if (!preferredVoice) {
                        console.warn(`‚ö†Ô∏è Saved voice "${this.voicePreference}" not found, using auto selection`);
                        preferredVoice = langVoices[0];
                    }
                }

                // Final fallback if no voice found for target language
                if (!preferredVoice && langVoices.length > 0) {
                    preferredVoice = langVoices[0];
                    console.warn(`‚ö†Ô∏è Using fallback voice for ${speechLang}: ${preferredVoice.name}`);
                }

                // CRITICAL: If still no voice, use ANY available voice (prevents silent failure on mobile)
                if (!preferredVoice && allVoices.length > 0) {
                    preferredVoice = allVoices[0];
                    console.error(`‚ùå No matching voice found, using first available: ${preferredVoice.name}`);
                }

                // Fail gracefully if absolutely no voices available
                if (!preferredVoice) {
                    console.error('‚ùå CRITICAL: No voices available at all! Cannot play TTS.');
                    this.processNextInQueue(); // Skip this item and continue
                    return;
                }

                utterance.voice = preferredVoice;
                console.log(`üîä Using voice: ${preferredVoice.name} (${preferredVoice.lang}) - Local: ${preferredVoice.localService}`);

                // Speech settings - optimize based on voice quality
                // High-quality voices sound better at normal pitch, low-quality need lower pitch
                const isHighQuality = preferredVoice && (
                    preferredVoice.name.includes('Neural') ||
                    preferredVoice.name.includes('Wavenet') ||
                    preferredVoice.name.includes('Studio') ||
                    preferredVoice.name.includes('Premium') ||
                    preferredVoice.name.includes('Enhanced') ||
                    !preferredVoice.localService
                );

                utterance.rate = this.speechRate;
                utterance.pitch = isHighQuality ? 1.0 : 0.92; // Natural pitch for HQ voices, lower for robotic ones
                utterance.volume = 1.0;

                console.log(`üîä TTS Settings: rate=${utterance.rate}, pitch=${utterance.pitch}, volume=${utterance.volume}, highQuality=${isHighQuality}`);

                // Event handlers
                utterance.onstart = () => {
                    console.log(`üîä Speaking (${this.ttsQueue.length} in queue): "${text.substring(0, 50)}..."`);
                    console.log(`üîä Actual utterance rate: ${utterance.rate}, pitch: ${utterance.pitch}`);
                };

                utterance.onend = () => {
                    console.log(`‚úÖ Finished speaking`);
                    // Process next item in queue
                    this.processNextInQueue();
                };

                utterance.onerror = (event) => {
                    console.error('üîä Speech synthesis error:', event.error);
                    // Continue to next item even on error
                    this.processNextInQueue();
                };

                // Speak
                this.speechSynthesis.speak(utterance);
            }

            updateAudioLevel(level) {
                // level is 0.0 to 1.0
                const percentage = Math.round(level * 100);
                this.audioLevelBar.style.width = `${percentage}%`;
                this.audioLevelText.textContent = `${percentage}%`;

                // Change color based on level
                if (level < 0.01) {
                    this.audioLevelText.style.color = '#999'; // Too quiet
                } else if (level < 0.1) {
                    this.audioLevelText.style.color = '#ff9800'; // Weak
                } else {
                    this.audioLevelText.style.color = '#4caf50'; // Good
                }
            }
        }

        // Initialize app
        const app = new GTranslateV4Client();
    </script>
</body>
</html>
